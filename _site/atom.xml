<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title></title>
 <link href="http://pepegramming.site/atom.xml" rel="self"/>
 <link href="http://pepegramming.site/"/>
 <updated>2024-08-16T16:03:39+03:00</updated>
 <id>http://pepegramming.site</id>
 <author>
   <name>Anton Davydov</name>
   <email></email>
 </author>

 
 <entry>
   <title>Как слежу за большими проектами</title>
   <link href="http://pepegramming.site/questions/graph-as-a-project-managment-tool/"/>
   <updated>2024-08-16T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/graph-as-a-project-managment-tool</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: как планируешь и следишь за долгими проектами? Особенно интересно что используешь для долгих проектов, которые дляться от года и больше, потому что в какой-то момент перестаю видеть «лес» за тасками в трекере.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Давайте разбираться. Важно: я не менеджер, людьми не управляю. Отчеты по работе и планированием спринтов тоже не занимаюсь. Поэтому буду говорить с позиции solution architect и касаемо только рабочих проектов.&lt;/p&gt;

&lt;p&gt;При этом, описываться будет личный опыт, из-за чего допускаю, что ответ подойдет далеко не всем: кто-то следит за проектами в «джире», кто-то получает результат от менеджеров. Поэтому буду рад если описанный подход либо вдохновит, либо поможет в текущей ситуации.&lt;/p&gt;

&lt;p&gt;И еще одно уточнение: в тексте буду использовать «джира» как обобщенное слово для любого PM инструмента. О jira тоже поговорим.&lt;/p&gt;

&lt;h2 id=&quot;контекст-в-котором-приходится-планировать-работу&quot;&gt;Контекст в котором приходится планировать работу&lt;/h2&gt;

&lt;p&gt;Для начала стоит описать контекст в котором нахожусь как solution architect. С этим поможет первая глава &lt;a href=&quot;https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/&quot;&gt;Solution Architecture Foundations&lt;/a&gt;, в которой описываются активности роли. Из списка хочется выделить три:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;управление доставкой решения, в которое входит роадмап из текущей ситуации в будущее, где проблема решена;&lt;/li&gt;
  &lt;li&gt;Организация процесса, в который входит коммуникации между стейкхолдерами на разные темы;&lt;/li&gt;
  &lt;li&gt;Взаимодействие со стейкхолдерами проекта, в которое входят как получение информации, которая потом шарится будет;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как можете понять, я не занимаюсь менеджментом разработчиков и людей (да и не хочу). Поэтому мне не надо считать сторипоинты, гадать сколько эпиков влезет в спринт и продавать &lt;a href=&quot;https://community.atlassian.com/t5/App-Central/3-tools-to-analyze-Cycle-and-Lead-Time-in-the-Jira/ba-p/1403775&quot;&gt;красивые графики по распределению времени работы&lt;/a&gt;. С другой стороны, во время работы необходимо понимать в каком состоянии находится проект, где затыки, объяснение почему что-то долго происходит и другие вещи, связанные с обсервабилити работы. Что бы было нагляднее, покажу на &lt;a href=&quot;https://en.wikipedia.org/wiki/V-model&quot;&gt;v-model&lt;/a&gt;, в какие моменты приходится наблюдать за тем, что делают другие.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/v-model-and-personal-managment.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Дизайн, имплементация и верификация – три фазы, на которых приходится «держать руку на пульсе»&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Т.е. задача сводится к трем вещам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;На этапе дизайна помочь спланировать работу и провалидировать, что план понятен и устраивает каждого стейкхолдера. А также проверить, что план влезает в ресурсы и цена решения будет приемлемой;&lt;/li&gt;
  &lt;li&gt;На этапе имплементации знать в каком состоянии находится проект и какие проблемы появляются. Плюс знать когда приступать к работе над другими частями системы (если требуется);&lt;/li&gt;
  &lt;li&gt;На этапе верификации нужно проверить, что система будет провалидирована перед тем, как оказаться в проде;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;По итогу, нужен инструмент который решает следующие проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Помогает в быстром прототипировании этапов работы и валидации этих этапов с каждым из стейкхолдеров проекта (бизнесом и разработчиками);&lt;/li&gt;
  &lt;li&gt;Инструмент должен работать для разных команд/отделов. Т.е. встречаются проекты, которые затрагивают от двух команд из разных отделов и необходимо синхронизировать последовательность работ между ними;&lt;/li&gt;
  &lt;li&gt;Важно как можно быстрее понять в каком состоянии проект на выбранный момент времени, или как быстро происходит требуемая эволюция. Т.е. в идеале, нужен инструмент, который позволит работать с «концептуальной» моделью работы над проектом (о концептуальной/логической/технической модели можно прочитать &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;в прошлом ответе&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;Так как ко мне могут прийти и спросить либо почему так долго выполняются работы, либо просто спросить что происходит – нужен артефакт для стейкхолдеров, который покажу и от меня отстанут;&lt;/li&gt;
  &lt;li&gt;Решение должно быть кросс-платформенное. Связано со спецификой работы, так как за последние четыре года использовались следующие инструменты: бейскамп, джира, редмайн, асана, миро (не спрашивайте), пяток штук для рисования ганта, гитхаб доски, трелло и другие. Если инструмент окажется вендорлоком - я не смогу решение протащить в другой проект;&lt;/li&gt;
  &lt;li&gt;Инструмент должен хранить задачи, которые вроде как надо бы сделать, но пока не понятно как, когда и нужно ли это вообще;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Дополнительные пожелания:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Чем меньше элементов и информации, тем лучше. Т.е. сроки, таймлайны и прочее хотелось бы убрать. Этим пусть занимаются тимлиды с командами;&lt;/li&gt;
  &lt;li&gt;Хочется иметь инструмент для собственной рефлексии:
  - Понимать на сколько изначальные планы отличаются от того, что получилось в конце эволюции;
  - Нужна ретроспектива, что бы быстро понимать как долго делаются задачи и замечать проблемы. Плюс понимать как сильно ошибался в начале и в конце работы (видеть как много добавилось нового во время работы)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;почему-project-management-tools-не-сработают&quot;&gt;Почему project management tools не сработают&lt;/h3&gt;

&lt;p&gt;Может показаться, что под требования подойдет любой продукт для project planning/management. На деле, подобные инструменты только усложняют работу и связано это с тем, что списки задач не работают для высокоуровневого планирования.&lt;/p&gt;

&lt;p&gt;Проблема тут в том, что задачи редко когда связаны последовательно между собой. В качестве примера можно привести «базовую» задачу по выносу кода из монолита в новый сервис. Если сильно не упарываться, то список шагов можно представить как такую последовательность: &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Сделать новый сервис с копией логики существующего модуля монолита

1. поднять новую базу данных
2. поднять болванку с пустым сервисом
3. настроить деплоймент
4. настроить observability (метрики, логи, etc)
5. настроить репликацию данных из монолита в новую базу данных
6. проверить, что данные валидны и соответствуют реальности
7. реализовать бизнес логику в сервисе
8. проверить, что бизнес логика работает корректно с данными
9. перевести трафик с монолита на новый сервис
10. проверить что итоговое решение работает корректно
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вроде кажется, что работа последовательна и тут нечего параллелить, достаточно сделать проекты под каждый шаг и фигачить пару месяцев.  Но если представить шаги как «граф», то оказывается, что есть как минимум три трека, в которых задачи могут быть распараллелены, а сам процесс не так линеен, как кажется на первый взгляд&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-service-extraction-final.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Тот же список по выносу логики из монолита, который теперь выглядит как граф, а не последовательные работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В тех инстурментах, что я знаю или использовал (jira, asana, basecamp, clubhouse, redmine, любая kanban доска, etc) нельзя быстро понять связь между задачами. Т.е. настроить и посмотреть связанные задачи можно, но в голове придется рисовать картинку выше, что отнимает время и силы. А в больших проектах, где задействуются команды из разных отделов, подобные действия могут превратиться в дни анализа. Хотя не исключаю, что я не преисполнился мудростью и плохо знаю инструменты, так как не менеджер.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/jira-go-brrr.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Подозреваю, что прошаренные менеджеры как-то так воспринимают этот текст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;мой-подход&quot;&gt;Мой подход&lt;/h2&gt;

&lt;p&gt;В 2019 году, пока работал в toptal, попробовал схему с графом, которая прижилась и которую использую до сих пор. Идейно подход напоминает &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;DAG&lt;/a&gt;, который используется как визуализатор задач в пайплайнах CI/CD или ETL. Единственное отличие, граф рисую руками, вместо использования &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as a code&lt;/code&gt; подхода.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/airflow-dag-visualizator.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Airflow DAG visualizator, который «рисует» шаги data flow в виде графа, где визуально понятно какая задача за какой вызывается и какой статус у каждой задачи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Главный плюс подхода – работает в любом инструменте. Я чаще использую lucidchart, но можно взять draw.io или аналоги, возможно даже diagram as code подойдет (не пробовал). Главное, чтобы выполнялись следующие условия:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Можно рисовать квадраты разных цветов;&lt;/li&gt;
  &lt;li&gt;Есть возможность связывать стрелками квадраты между собой;&lt;/li&gt;
  &lt;li&gt;Можно добавлять отдельный элемент для комментариев (в идеале стикер);&lt;/li&gt;
  &lt;li&gt;Наличие отдельных вкладок для версионирования (об этом дальше);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Сам процесс работы с графом состоит из трех шагов:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Планирование;&lt;/li&gt;
  &lt;li&gt;Наблюдение;&lt;/li&gt;
  &lt;li&gt;«Рефлексия»;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте, на примере выноса кода в отдельный сервис, пройдем по каждому из шагов&lt;/p&gt;

&lt;h3 id=&quot;шаг-1-планирование&quot;&gt;Шаг 1: планирование&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Предупреждаю: скорее всего сам план будет не корректен, но у меня цель идею показать, а не «правильно» спланировать работу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Первым делом придется понять что за задачи нужно выполнить. В примере выносом кода в отдельный сервис можно сразу сказать три задачи которые необходимо выполнить:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поднять новый и пустой сервис&lt;/li&gt;
  &lt;li&gt;Перенести логику в сервис&lt;/li&gt;
  &lt;li&gt;Перевести трафик с монолита на новый сервис&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В виде графа это будет выглядеть следующим образом:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-base.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждый шаг – отдельная нода графа, связи – показывают что за чем выполнять по плану&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Дальше наступает этап анализа, когда оказывается, что каждый из трех шагов состоит из специфичных действий: поднять новый сервис включает в себя поднятие необходимой базы, инстанса приложения, создания репозитория, настройку CI/CD, observability. При этом, без observability перевод трафика не будет иметь смысл.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-first-improvements.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Раскрываем «большие» задачи на конкретные шаги, которые необходимо выполнить&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Когда будут +- понятные задачи, советую отдельно подумать о двух вещах: интеграции и валидации.&lt;/p&gt;

&lt;p&gt;Под интеграции попадает все, что связывает два элемента вместе: вызов внешнего API, перенос данных из базы в базу, вызов API внутреннего сервиса, перенос данных из старой схемы в новую схему в рамках одной бд, наполнение данными нового сервиса/новой базы и так далее. Об интеграциях забывают в планировании, но как подсказывает практика, тут больше всего риска провалиться: сорвать срок, получить не консистентность и затянуть с работой. &lt;/p&gt;

&lt;p&gt;А под валидации попадает вся левая часть v-model: валидация адекватности данных, которые перенесли, валидация что решение работает, валидация что сервис правильно раскатался, валидация интеграций и так далее. Также как и в интеграциях, валидации забываются и тут много рисков/проблем, которые чаще выстреливают, чем нет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-integration-and-validation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Белые квадраты – интеграции и валидации о которых забывают, но которые не менее важны, чем написание кода и деплой&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Как сделаете план, важно согласовать шаги с командой. Тут два ключевых стейкхолдера: те, кто будут выполнять работу (чаще разработчики, тестировщики, дизайнеры и так далее) и менеджеры, которые будут выбивать ресурсы под работу. Возможно граф станет еще больше или часть задач изменится, это нормально. Важно, чтобы каждый согласился работать по представленному плану.&lt;/p&gt;
&lt;h4 id=&quot;советы&quot;&gt;Советы&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Есть риск скатиться в дробление задач на супер мелкие куски. Не вижу ничего плохого в этом, особенно если опыта мало. Подобные задачи можно схлопнуть или выкинуть на ревью. Единственное исключение – низкоуровневые технические задачи, которые стоит оставлять только если задачи супер критичные для проекта. Если нет, лучше использовать чеклисты для валидации (например сделать чеклист для изменения схемы бд с шагами и проверками);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Всегда&lt;/strong&gt; (это важно) думайте о необходимых интеграциях и валидациях, без которых проект не запустится. Помните, что есть разница между сделать и заставить работать без ошибок;&lt;/li&gt;
  &lt;li&gt;Согласование такой же необходимый шаг, как и создание графа. Если придти и с ноги сказать кто, что и как делать будет – велик риск саботажа. Плюс другие люди могут указать о том, что вы забыли добавить или что часть работы можно выкинуть;&lt;/li&gt;
  &lt;li&gt;Один из возможных «smell-ов» по задачам – появление задачи, которая ни с чем не связана. Т.е. у задачи может быть либо входящая, либо исходящая связь (либо две сразу), но полное отсутствие стрелок является знаком, что что-то не так и стоит посмотреть внимательно (исключение – задачи в будущее, которые важно помнить, но непонятно когда и как их делать);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-2-наблюдение&quot;&gt;Шаг 2: наблюдение&lt;/h3&gt;

&lt;p&gt;Нудный и в тоже время важный шаг. Каждый спринт встречаемся с исполнителями, проходим по каждой задачи из графа, оставляем комментарии и добавляем новые задачи, если оказалось что они нужны. Плюс отмечаем что было сделано и что в работе на момент ревью. Для этого использую цвета: зеленый – сделали, желтый – в работе, красный – отменили.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-full-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Реальный граф связанный с рефакторингом сервиса. Комментарии оставляю как стикер, тут нет стандартизации. К сожалению шакально по причине NDA, но идею по картинке понять можно&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут важно сохранять прошлую версию графа отдельно. Для этого делаю копию, ставлю текущую дату (версию) и заполняю скопированный граф&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-graph-versions.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая вкладка – новая версия графа, которая изменяется&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря такому версионированию, можно ретроспективно посмотреть как долго задачи делаются, что добавилось нового и исследовать процесс выполнения работы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;https://leonardo.osnova.io/6c44e586-3769-4c22-4270-a326d823ea8c/-/format/mp4#t=0.1&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В 2020 году, Самат &lt;a href=&quot;https://vc.ru/services/151374-s-pomoshyu-diagramm-mozhno-obyasnit-chto-ugodno-tem-bolee-dlya-etogo-est-klassnye-instrumenty&quot;&gt;написал статью&lt;/a&gt;, где показывал граф выполнения работ (в самом низу), видео как раз из статьи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме отметок по задачам, использую секцию «Проблемы/вопросы/комментарии», куда добавляю все, о чем говорят исполнители. В будущем секция помогает в анализе и ретро.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-pros-cons-ideas.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример секции «Проблемы/вопросы/комментарии» из проекта выше. Красное – проблемы, зеленое – комментарии, желтым обозначаю вопросы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;По итогу, получаем гибкий инструмент, который можно использовать для ответа «в каком статусе проект» и «почему долго делается ХХХ?!».&lt;/p&gt;

&lt;h4 id=&quot;советы-1&quot;&gt;Советы&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Как я уже сказал - наблюдение важный шаг. Но при этом и сложный из-за регулярности и желания пропустить и забить. Советую хотя бы раз попробовать выполнить проект не забивая на этот шаг и после уже решать, подходит подход или нет;&lt;/li&gt;
  &lt;li&gt;Версионирование графа – ключ к успеху, особенно для шага с анализом;&lt;/li&gt;
  &lt;li&gt;Не бойтесь добавлять новые задачи. Невозможно сразу описать план идеально. В моей практике, в итоговой версии графа оказывается на ~40% больше задач, чем в изначальной версии;&lt;/li&gt;
  &lt;li&gt;Секция с проблемами не обязательна, но помогает сохранить контекст на будущее;&lt;/li&gt;
  &lt;li&gt;У каждого стейкхолдера должен быть доступ к графу в любое время. Разработчики смогут быстро посмотреть что делать дальше, а у бизнеса появится обсервабилити над проектом в любой необходимый момент времени;&lt;/li&gt;
  &lt;li&gt;В теории, можно раз в неделю открывать «джиру» и отмечать самому что в работе, а что планируется. Но у такого подхода есть минус – шаги не просматриваются исполнителями и нет контакта, благодаря которому можно поговорить о косяках в планировании или проблемах в реализации;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-3-рефлексия&quot;&gt;Шаг 3: «рефлексия»&lt;/h3&gt;

&lt;p&gt;Это опциональный пункт. Идея в том, что по завершению проекта, любят устраивать ретро. Если проект длится больше 6 месяцев – шансы вспомнить что было в начале нулевые. Но благодаря графу можно быстро посмотреть как долго делались задачи, выписать какие проблемы возникли (с решениями) и посмотреть на сколько ожидания разошлись с реальной работой.&lt;/p&gt;

&lt;h2 id=&quot;advanced-использование-графа&quot;&gt;Advanced использование графа&lt;/h2&gt;

&lt;p&gt;Чтобы накидать ещё больше пользы в ответ, решил еще добавить секцию связанную с анализом. Тут будут идеи из личного опыта, поэтому не ждите хардскилового менеджмента.&lt;/p&gt;

&lt;h3 id=&quot;поиск-проблем&quot;&gt;Поиск проблем&lt;/h3&gt;

&lt;p&gt;В секции с шагом планирования упоминались «висящие» задачи. Кроме этого есть еще один «smell». Связан он с ситуацией, когда задача блокирует другие задачи, например вот так:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-task-blocker.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Центральная задача блокирует правые. При этом, центральная задача ждет левые&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Проблема тут в том, что нельзя распараллелить выполнение работ из-за центрального блокера. Это не всегда плохо, но советую подумать, как можно блокер разбить на несколько задач, которые позволят разблокировать параллельность.&lt;/p&gt;

&lt;h3 id=&quot;как-срокиресурсы-считать&quot;&gt;Как сроки/ресурсы считать&lt;/h3&gt;

&lt;p&gt;Сразу скажу, делал такое 2 раза в жизни, но оба раза срабатывало. Идея в том, что сначала проставляется оценка задачам, после чего планируется, сколько команд надо для работы. В результате можно предположить сколько людей и в какой последовательности будут происходить работы. Благодаря чему заранее выбить капасити каждой команды и предположить сколько времени займет работа (немного точнее, чем просто «пальцем в небо»).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-resource-planning.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Что бы вынести сервис из монолита нужно 4 команды (каждый цвет – отдельная команда), причем левые три команды могут работать параллельно, а последняя нужна только в самом конце и до реализации бизнес логики может отдыхать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подход полезен в двух случаях: когда надо посчитать «пальцем в небо» стоимость и когда проект реализуется сразу несколькими командами и нужно кросс командное взаимодействие.&lt;/p&gt;

&lt;h3 id=&quot;как-понять-почему-по-срокам-не-укладывайтесь&quot;&gt;Как понять, почему по срокам не укладывайтесь&lt;/h3&gt;

&lt;p&gt;Специально для ситуаций, когда бизнес не понимает, почему изначальный коммит был на полгода, а прошло уже 2 года и проект не приносит денег. Благодаря графу можно наглядно показать как увеличился пул задач или какие задачи долго висели в блоке. Судя по опыту, это выглядит намного нагляднее для не-менеджеров, чем графики «джиры».&lt;/p&gt;

&lt;p&gt;Плюс, если за 2-3 спринта задачи только добавляются в граф, а прогресса нет – время бить тревогу и пинать менеджмент/бизнес, что проблемы начались.&lt;/p&gt;

&lt;h3 id=&quot;используем-реальный-анализ-графов&quot;&gt;Используем реальный анализ графов&lt;/h3&gt;

&lt;p&gt;Так как это граф, можно применить научные методики анализа из теории графов. Но тему не раскручивал, поэтому оставлю идею для самостоятельного изучения. Если что-то придумаете, напишите пожалуйста, буду рад обсудить.&lt;/p&gt;
&lt;h3 id=&quot;как-использовать-project-management-tools-с-таким-графом&quot;&gt;Как использовать project management tools с таким графом&lt;/h3&gt;

&lt;p&gt;Если взять &lt;a href=&quot;https://pepegramming.site/questions/data-model/#data-modelling&quot;&gt;идею conceptual/logical/physical data models&lt;/a&gt;, то можно представить граф как концептуальную модель, PM tool как логическую, а реализацию в виде кода как физическую&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/conceptual-logical-phisical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Наглядное сравниение каждой data model и планирования работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Из этого сравнения получается, что есть условный «эпик», который описывается графом. Каждая нода графа – отдельный проект в «джире», а каждый таск из проекта – отдельный PR/MR, который на шаг ближе закрывает эпик.&lt;/p&gt;

&lt;p&gt;Благодаря такому разделению, можно использовать viewpoints для каждого стейкхолдера: список задач для команды, гант диаграмму по эпику, статус проекта для бизнеса, задачи для конкретного разработчика и так далее.&lt;/p&gt;

&lt;p&gt;А если используете &lt;a href=&quot;https://habr.com/ru/articles/831922/&quot;&gt;трассировку требований&lt;/a&gt;, сможете линковать между собой. Единственный минус подхода, для графа нет автоматизации.&lt;/p&gt;

&lt;h2 id=&quot;плюсы-и-минусы-использования-графа-для-планирования&quot;&gt;Плюсы и минусы использования графа для планирования&lt;/h2&gt;
&lt;p&gt;Начну с плюсов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Появляется хоть какая-то системность в планировании и выполнении проекта. Благодаря чему каждый из стейкхолдеров может рассматривать &lt;a href=&quot;https://creatime.me/MediaLibrary/UchebnyeMaterialy-2/Stati/PodsistemyI&quot;&gt;либо подсистемы либо надсистемы&lt;/a&gt; в зависимости от собственных интересов;&lt;/li&gt;
  &lt;li&gt;Лично доволен таким подходом, за пять лет проблем не было;&lt;/li&gt;
  &lt;li&gt;Когда проектов больше пяти – помогает быстро получить контекст в каком состоянии реализация каждого;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, бизнес любит такую наглядность. Разработчики страдают от того, что сложно хайлевел задачи декомпозировать и понять что за чем – поэтому декомпозицию можно обсудить заранее. Пару раз ребята говорили спасибо, ибо понимали что их дальше ждет и могли заранее подготовить код к будущей работе;&lt;/li&gt;
  &lt;li&gt;Из-за концептуальности и простоты решения – супер гибкое решение. Выбираете удобный вам инструмент для диаграмм и работаете. Только помните, что в случае вайтбордов придется решить, как версионировать графы. Плюс, с добавлением трассировки требований, можно быстро делать кросс линки между задачами и другими артефактами работы;&lt;/li&gt;
  &lt;li&gt;Концептуальный план делается быстро и легко правится. После можно сделать «логический» план в виде задач или эпиков в джире и сразу начать работать, вместо того, что бы тратить время на реализацию концептуального плана в PM tool;&lt;/li&gt;
  &lt;li&gt;Хорошо показывает себя в проектах, где есть четкая цель, которая не поменяется через пол года и которую долго делать. Например, когда знаете, что надо вынести сервис, отрефакторить кусок кода или реализовать фичу с определенным DoD. Один раз сделали, знаете конец и дальше работаете, раз в спринт сверяясь;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, работает для ретро лучше, чем список задач из джиры (возможно ошибка выжившего). Связано с тем, что подход добавляет концепцию «журнала» связанного с проблемами, хорошими вещами и вопросами. После чего, на ретро, открываем нужный спринт и смотрим, что там происходило;&lt;/li&gt;
  &lt;li&gt;Не совсем о подходе, но скорее в целом о полном плане работ: включается &lt;a href=&quot;https://fs.blog/amateurs-professionals/&quot;&gt;мышление второго порядка&lt;/a&gt;. Особенно, если план валидировать через результат каждого шага + вопроса “что произойдет после этого”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После плюсов может показаться, что инструмент серебряная пуля, но минусов у графа тоже много:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;К концу релиза начинается каша и велик риск забить на диаграмму. Нужен высокий уровень самоконтроля и постоянно пушить исполнителей. Из этого следует главный минус – без контроля и ревью, подход не работает;&lt;/li&gt;
  &lt;li&gt;Не сработает, когда высокая неопределенность в работе. Т.е. когда сделав задачу, планы меняются и становятся другими, например сегодня выносите сервис, а завтра оказывается, что денег больше нет и надо гипотезы делать по две штуки в день;&lt;/li&gt;
  &lt;li&gt;Это придуманный подход, его нет нигде. Поэтому допускаю проблемы с объяснением и обучением, так как нет описания. Т.е. кроме куска из курса о системах и этого текста, в интернете информации нет (если ошибаюсь и знаете аналоги, буду рад ссылке);&lt;/li&gt;
  &lt;li&gt;Придется заморочиться с трассировкой требований, если нужна интеграция с проектной документацией. Это лишняя работа и цена;&lt;/li&gt;
  &lt;li&gt;Подход придется продавать бизнесу, менеджерам и исполнителям работы. Продажа подхода – одна из причин, почему появился этот текст;&lt;/li&gt;
  &lt;li&gt;Из инструментов – кривые плагины для конфлюенса и аналогов, либо делать руками. Если используете диаграммы - нет фильтрации по проектам/командам и автоматической генерации других viewpoints;&lt;/li&gt;
  &lt;li&gt;Подход не о сроках и датах. Если сроки важны, придется либо делать отдельный viewpoint (например ганта), либо использовать другой инструмент;&lt;/li&gt;
  &lt;li&gt;Менеджерам будет не хватать асайнов на людей, фильтрации и сроков/статусов;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Использование подобного графа оправданно, если необходим «концептуальный» уровень для планирования проектов, а условная «джира» не справляется. Так как подход максимально гибок, можно использовать любые инструменты для диаграмм или вайтбордов (можно даже лист бумаги и ручку взять). Важно помнить, что стоит делать квадраты похожими на проект из GTD и следить за связями. При этом, кроме работы над планом, стоит потратить время на регулярное обновление статуса по проекту, что в будущем окупится аналитикой и ретро.&lt;/p&gt;

&lt;p&gt;Ну и еще раз напишу, что описанный подход планирования и слежения за проектами не единственный и не серебрянная пуля. Ну и помните главное правило: если устраивает текущая ситуация в компании – лучше ничего не трогать и не гнаться за новым подходом, ради подхода.&lt;/p&gt;

&lt;p&gt;Кроме этого, если используете «концептуальный» вью в PM инструментах, буду рад, если поделитесь секретом в комментариях. А если захотите воспользоваться описанным выше подходом и останутся вопросы или захотите поделиться фидбеком – буду рад в два раза больше.&lt;/p&gt;

&lt;h2 id=&quot;доп-ссылки&quot;&gt;Доп ссылки&lt;/h2&gt;

&lt;p&gt;Инструменты, представляющие работу над задачей в виде графа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.i.ntention.app&quot;&gt;Intention&lt;/a&gt;, работает на андроиде и в вебе (если понял правильно). &lt;a href=&quot;https://news.ycombinator.com/item?id=22591311&quot;&gt;Обсуждение на ycombinator&lt;/a&gt; тоже присутствует;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eyen.fr/taskheat/&quot;&gt;Приложение за которым долго слежу&lt;/a&gt; и от которого были большие ожидания для персональных проектов, но так и не зашло. Возможно попробую еще раз через пару лет. Работает только на apple устройствах и больше о персональных проектах, т.е. конкурент для things3/todois/ticktick/etc;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gameplan.global&quot;&gt;PM tool, о котором никогда не слышал&lt;/a&gt; (нашел, пока ответ писал). Кажется, что если используете что-то другое, переехать на «нонейм» решение будет сложно;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.easyredmine.com/redmine-wbs-plugin&quot;&gt;Плагин для редмайна&lt;/a&gt; с похожей функциональностью;&lt;/li&gt;
  &lt;li&gt;Два плагина для джиры с похожим функционалом: &lt;a href=&quot;https://marketplace.atlassian.com/apps/1216207/issue-links-viewer&quot;&gt;первый&lt;/a&gt; и &lt;a href=&quot;https://whiteboards.io&quot;&gt;второй&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Как визуализировать схему базы данных</title>
   <link href="http://pepegramming.site/questions/data-model/"/>
   <updated>2024-08-01T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/data-model</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;«Возникла проблема, что нужно визуализировать данные, но не понятно с чего начать. Что в таких случаях делаешь и какие есть инструменты для этого?»&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос без конкретики, выделю два случая:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Проект только в голове и хочется понять как связаны данные между собой&lt;/li&gt;
  &lt;li&gt;Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Поэтому, вместо короткого ответа «используй ERD», поговорим о каждом из вариантов. Но сначала разберемся с data modelling, благодаря которому можно определить нужный вид диаграммы для задачи.&lt;/p&gt;

&lt;h2 id=&quot;data-modelling&quot;&gt;Data modelling&lt;/h2&gt;

&lt;p&gt;Может показаться, что взять и начать фигачить SQL схему описывающую данные для проекта может быть разумной идеей. На деле это не так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как нет структуры данных в голове, можно запутаться и упороться в вечное редактирование. А если данных много и связей еще больше - получится хаос который не влезет в голову;&lt;/li&gt;
  &lt;li&gt;Полученную модель данных придется валидировать, причем с бизнесом/доменным экспертом. Не разработчикам будет сложно и валидация может затянуться;&lt;/li&gt;
  &lt;li&gt;Когнитивная нагрузка увеличивается: работая с текстом, придется этот текст представить в виде модели в голове и потом обратно, из модели в текст;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/schema-vs-visualisation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева - схема в dbml, которая представлена в виде диаграммы (справа). Когда разбираешься с новым проектом – мне проще сразу картинкой (моделью) оперировать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В целом, выглядит надежно, как швейцарские часы. Поэтому придумали процесс, который назвали &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_model&quot;&gt;data modeling&lt;/a&gt;. Data modeling помогает с определением релевантных для системы данных, связью между этими данными и как данные работают вместе, т.е. создать data model для системы. Главное, что стоит вынести из этой идеи – моделирование можно разбить на три «перспективы»:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conceptual_schema&quot;&gt;Концептуальная&lt;/a&gt; говорит о том, какие данные используются системой и как данные связаны между собой. Т.е. тут о том, что необходимо бизнесу без привязки к конкретной реализации хранения данных в конкретной бд&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_schema&quot;&gt;Логическая&lt;/a&gt; говорит о том, как данные структурируются в приложении. Т.е. берем любой язык описания схемы (будь то SQL, dbml или еще что) и описываем таблицы/колонки/классы/etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_schema&quot;&gt;Физическая&lt;/a&gt; говорит о том, как данные физически храниться будут. Т.е. берем логическое описание и говорим где данные будут находиться физически и как все будет работать в реальности;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/conceptual-vs-logical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сравнение концептуальной (правая) и логической (левая) схем, где пример из самого начала. Возможно, я сделал концептуальную модель не корректно, но задача показать идею, а не сделать корректную модель&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При использовании концептуальной модели данных можно отказаться от «технической» информации и оставить только необходимое для реализации бизнесовой модели. Т.е. можно не запариваться с pk, fk и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; для каждого объекта и не думать о таблицах. Так, в примере выше, указан продукт как «элемент», к которому привязаны отдельные «элементы»: цена, тег и статус. Эта информация необходима для бизнес логики, хотя в реальности, если опуститься на логический уровень – данные оказываются в одной таблице.&lt;/p&gt;

&lt;p&gt;Теперь, используя информацию о data modeling, можно вернуться к оригинальному вопросу.&lt;/p&gt;

&lt;h2 id=&quot;случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой&quot;&gt;Случай 1: Проект только в голове и хочется понять как связаны данные между собой&lt;/h2&gt;

&lt;p&gt;Возможно бизнес с нуля делает систему, либо же нужно разобраться в уже работающей бизнес логике (доменной модели). Для этого придется разбираться с данными: какие элементы, как элементы связаны. Если в этот момент думать о том, где какая таблица будет и что в этой таблице должно находиться – выглядит как доп нагрузка которая усложняет работу. Поэтому для первого случая концептуальное представление предпочтительнее: меньше когнитивная нагрузка, проще работать, можно показать бизнесу не объясняя что это за &lt;a href=&quot;https://www.datensen.com/blog/er-diagram/one-to-many-relationships/&quot;&gt;вилка&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-нотаций-концептуальных-моделей&quot;&gt;Виды нотаций концептуальных моделей&lt;/h3&gt;

&lt;p&gt;Тут список может быть большой, опишу только то, что сам знаю и видел. Подробно на каждой нотации останавливаться не буду, оставлю это на самостоятельное изучение.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77224/informatika/notatsiya_idef&quot;&gt;Нотация IDEF 1х&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77225/informatika/notatsiya_uml&quot;&gt;PlantUml&lt;/a&gt;, тут используется &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram&quot;&gt;class diagram&lt;/a&gt;, что сомнительно, но для общего развития пусть будет.&lt;/li&gt;
  &lt;li&gt;Cтоит упомянуть &lt;a href=&quot;http://www.modelsphere.com/org/index.html&quot;&gt;Open ModelSphere&lt;/a&gt;, это oss инструмент, который помогает с моделированием данных не только концептуально, но и логически/физически
 
Отдельно хочется рассказать еще о двух нотациях:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первая нотация – &lt;a href=&quot;https://en.wikipedia.org/wiki/Entity–relationship_model&quot;&gt;ER model&lt;/a&gt; (иногда встречается как &lt;a href=&quot;https://studme.org/77222/informatika/notatsiya_pitera_chena&quot;&gt;нотация Питера Чена&lt;/a&gt;) и тут важно не путать с ER diagram. Модель создана Питером Ченом в 1976 году для абстрактного описания данных. При этом, модель предоставляет абстракции для концептуального/логического/физического моделирования. Интересный факт: эта одна из нотаций, которые повлияли на UML.&lt;/p&gt;

&lt;p&gt;Вторая – &lt;a href=&quot;https://martinfowler.com/books/ap.html&quot;&gt;нотация концептуальной модели Мартина Фаулера из книги&lt;/a&gt;, о которой преступно мало знают.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/martin-fowler-notation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Так выглядит нотация используемая Фаулером, она описана прямо на первых страницах книги&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Что выбрать – решайте сами. Расскажу о том, что сам использую и почему редко использую описанные выше модели.&lt;/p&gt;

&lt;h3 id=&quot;что-сам-использую&quot;&gt;Что сам использую&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#34413c7cc27b4e1da6ee31177875b93b&quot;&gt;Я использую сильно упрощенную нотацию, состоящую только из квадратов и стрелок&lt;/a&gt;, которую сам и «придумал». При этом, вместо использования сложных видов стрелок, подписываю вид связи который нужен (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_one&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_has_one/many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;many_to_many&lt;/code&gt;). Плюс использую цветовое обозначение для данных, которые используются в разных контекстах.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/data-model-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример модели из рабочего проекта. Тут кусок модели, &lt;a href=&quot;https://vc.ru/fedorandsamat/1103649-kak-my-perezapuskali-medicinskuyu-informacionnuyu-sistemu&quot;&gt;связанный с работой дантистов&lt;/a&gt;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Такой выбор обусловлен двумя причинами:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальную модель приходится валидировать с бизнесом/доменными экспертами. Чем сложнее нотация, тем больше шансов, что человек запутается. Плюс грузить и без этого занятых людей так себе подход.&lt;/li&gt;
  &lt;li&gt;Внимательность – не обо мне, поэтому с большим шансом запутаюсь или пропущу стрелку/форму и по итогу получится фигня. Рисковать и проверять себя по 10 раз не хочется.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если в компании уже есть стандарт, либо хотите использовать распространенный стандарт – лучше забыть эту часть текста и использовать то, что уже принято. Если ничего такого нет, возможно стоит скопировать мое решение, а после, если этого окажется мало, выбрать любую из описанных выше нотаций.&lt;/p&gt;

&lt;h3 id=&quot;советы-для-моделирования-данных-не-схемы-бд&quot;&gt;Советы для моделирования данных (не схемы бд)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Забудьте о таблицах и реализации в бд. Начните с данных, которые необходимы для работы бизнес модели. Главная причина такого категоричного совета – проще замапить корректную концептуальную модель на реализацию конкретной базы данных, чем упороться с реализацией и потерять важные данные. Это может привести к тому, что решение не будет бизнес задачу решать, а будет подстраиваться под техническое решение, вокруг которого зацепитесь;&lt;/li&gt;
  &lt;li&gt;Вытекает из первого совета: в концептуальной модели не нужны данные, которые окажутся в базе данных. Поэтому о &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, etc можно забыть. Только если это не часть доменной модели;&lt;/li&gt;
  &lt;li&gt;Не важно какую нотацию выбрали, модель без легенды – деньги на ветер;&lt;/li&gt;
  &lt;li&gt;Валидируете модель с бизнесом/доменным экспертом;&lt;/li&gt;
  &lt;li&gt;Между дублированием элементов и уменьшением стрелок – выбирайте дублирование. Так можно снизить когнитивную нагрузку, которая появится из-за стрелочного хаоса. По этой же причине старайтесь избегать пересечения стрелок;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С моделированием разобрались. Давайте поговорим о генерации картинок из схемы бд.&lt;/p&gt;

&lt;h2 id=&quot;случай-2-проект-уже-реализован-в-коде-и-хочется-понять-что-из-себя-представляет-схема-бд&quot;&gt;Случай 2: Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/h2&gt;

&lt;p&gt;В данном случае, если нужна концептуальная модель – инструментов не знаю, к сожалению. Поэтому, для проектов с реализованной схемой бд, рисую концептуальные модели «руками».&lt;/p&gt;

&lt;p&gt;Но если хватит логической модели, можно найти решение. Из того что знаю – ER diagram (которая, является подмножеством ER model). Существует новомодный dbml, который тоже использовал. Еще стоит упомянуть &lt;a href=&quot;https://studme.org/77223/informatika/notatsiya_martina_crows_foot&quot;&gt;Нотацию Мартина (Crow’s Foot)&lt;/a&gt;, но в живую не наблюдал. Если знаете другие варианты – буду рад комментариями, ибо самому интересно, а быстро нагуглить альтернативы не вышло.&lt;/p&gt;

&lt;p&gt;Для генерации «картинки» я использую следующие подходы:&lt;/p&gt;

&lt;h3 id=&quot;генерация-модели-из-кода&quot;&gt;Генерация модели из кода&lt;/h3&gt;

&lt;p&gt;В эту секцию входят:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;инструменты diagram as a code: &lt;a href=&quot;https://graphviz.org/Gallery/neato/ER.html&quot;&gt;graphiz&lt;/a&gt;, &lt;a href=&quot;https://mermaid.js.org/syntax/entityRelationshipDiagram.html&quot;&gt;mermaid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;библиотеки для разных языков (&lt;a href=&quot;https://github.com/drivendataorg/erdantic&quot;&gt;python&lt;/a&gt;, &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;ruby&lt;/a&gt;, &lt;a href=&quot;https://github.com/fuelen/ecto_erd&quot;&gt;elixir/ecto&lt;/a&gt;, &lt;a href=&quot;https://github.com/gmarik/go-erd&quot;&gt;golang&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/prisma-erd-generator&quot;&gt;js/prisma&lt;/a&gt;, etc) которые под капотом используют graphiz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С вероятностью в 99% там будет ERD. А подход подойдет в двух случаях:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Если схема данных меньше ~15 таблиц и хочется быстро подключить генератор, а после забыть и получать каждый релиз новый артефакт;&lt;/li&gt;
  &lt;li&gt;Если модель нужна для поста или показать идею;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Работает для схем, где таблиц меньше ~15 или когда связей мало между таблицами;&lt;/li&gt;
  &lt;li&gt;Библиотеки работают из коробки и легко настраиваются;&lt;/li&gt;
  &lt;li&gt;Если говорим о библиотеках – нет проблем с обновлением схемы после изменений, так как генерируется новый файл;&lt;/li&gt;
  &lt;li&gt;Легко шарить между коллегами. Отправляем картинку в чат, добавляем в репозиторий или конфлюенс/ноушен/etc;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нельзя поменять положение элементов или связей. А автоматическая генерация не поддается логике;&lt;/li&gt;
  &lt;li&gt;На больших схемах получается не читаемая каша. Особенно, когда дело касается связей;&lt;/li&gt;
  &lt;li&gt;Генерируется векторная картинка, если схема увесистая – может шакалить;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-erd-в-инструментах-для-диаграм&quot;&gt;Генерация ERD в инструментах для диаграм&lt;/h3&gt;

&lt;p&gt;Lucidchart предоставляет &lt;a href=&quot;https://www.lucidchart.com/pages/examples/er-diagram-tool&quot;&gt;инструмент, который генерирует ERD по загруженной схеме бд&lt;/a&gt;. Дальше получаете диаграмму, в которой можно двигать элементы, стрелки, добавлять новые элементы, менять цвета и делать что угодно.&lt;/p&gt;

&lt;p&gt;Draw.io реализовали &lt;a href=&quot;https://www.drawio.com/doc/faq/sql-plugin&quot;&gt;аналогичный инструмент&lt;/a&gt;. Только для работы придется вставлять SQL код. После, с полученной схемой, также можно производит манипуляции с диаграммой.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/erd-bad-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример сгенерированной ERD в lucidchart. Получи такое картинкой – сразу бы отказался от проекта&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В отличии от векторной картинки – можно делать с полученной моделью что угодно;&lt;/li&gt;
  &lt;li&gt;Если не хватит сгенерированных элементов – можно добавить (например стикеры и комментарии);&lt;/li&gt;
  &lt;li&gt;Если схема большая – можно двигать каждую связь или элемент, плюс выручает поиск по модели;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Могут теряться связи между элементами, особенно если связи указаны в коде, но не учтены в схеме бд. Пару раз попадался на эту уловку и приходилось руками достраивать модель, что малоприятно;&lt;/li&gt;
  &lt;li&gt;Хоть с диаграммой можно делать что угодно, но первичная генерация хаотична. Поэтому для «наведения порядка» придется самостоятельно двигать элементы;&lt;/li&gt;
  &lt;li&gt;Специфичный импорт, из-за чего придется под новую версию схемы делать новую диаграмму. А если добавили что-то кастомное, придется дублировать руками;&lt;/li&gt;
  &lt;li&gt;Шарить модель может быть проблемно, особенно если используете lucid и душит жаба платить за кучу людей (но для конфлюенса был плагин);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Заметка: помните, что генераторы ERD присутствуют не везде. Например, &lt;a href=&quot;https://miro.com/diagramming/er-diagram/&quot;&gt;в miro нет ERD генераторов&lt;/a&gt;, вместо этого, получите только элементы для того, чтобы самостоятельно рисовать модель. &lt;/p&gt;

&lt;h3 id=&quot;использование-dbml&quot;&gt;Использование dbml&lt;/h3&gt;

&lt;p&gt;Персональное открытие прошлого года. Вместо рассказа, &lt;a href=&quot;https://dbdiagram.io/d&quot;&gt;лучше посмотреть самостоятельно&lt;/a&gt; (в верхнем левом углу, где лого, можно загрузить advanced sample, который использовался в примерах в начале статьи).&lt;/p&gt;

&lt;p&gt;При этом, так как dbml схема типизирована, можно написать конвертер из erd в dbml и получить генерацию схемы из кода (делал так для &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;erd-rails&lt;/a&gt; генератора). После, вставляем схему в редактор и изучаем схему баз данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Из-за динамичности, можно двигать элементы, что работает с большими схемами;&lt;/li&gt;
  &lt;li&gt;Diagram as a code. Можно &lt;a href=&quot;https://dbml.dbdiagram.io/cli#convert--a-sql-file-to-dbml&quot;&gt;генерировать dbml схему по SQL&lt;/a&gt;, присутствует &lt;a href=&quot;https://github.com/stepanic/parse-server-SCHEMA-to-DBML&quot;&gt;библиотека для монги (не проверял)&lt;/a&gt;, &lt;a href=&quot;https://github.com/hamedsj/DbmlForDjango&quot;&gt;для джанги&lt;/a&gt; библиотека существует;&lt;/li&gt;
  &lt;li&gt;Предпросмотр работает в браузере, не надо ничего ставить локально;&lt;/li&gt;
  &lt;li&gt;Так как генерация из кода – можно избежать ситуации, когда связи не отображаются, так как связей нет в схеме бд, но есть на уровне кода;
  
&amp;lt;/br&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нет нормальной экосистемы. Библиотеки придется писать самому, в частности для мало популярных языков;&lt;/li&gt;
  &lt;li&gt;Еще один язык описания схемы, который придется изучить;&lt;/li&gt;
  &lt;li&gt;Если хотите хранить и смотреть модели командой, придется платить. Хотите селфхостед – на 2023 год находил аналоги, но каждый оставлял желать лучшего;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-из-редактораide&quot;&gt;Генерация из редактора/IDE&lt;/h3&gt;

&lt;p&gt;Так как всю жизнь просидел в vim, без возможности выхода, то особо ничего сказать о генерации схем из редактора и инструментов для этого. Знаю, что инструменты существуют и пользователи jetbrains &lt;a href=&quot;https://www.jetbrains.com/help/datagrip/creating-diagrams.html#db_diagrams&quot;&gt;могут смотреть на схему не выходя из редактора&lt;/a&gt;. Лучше погуглить самостоятельно.&lt;/p&gt;

&lt;h2 id=&quot;итоги&quot;&gt;Итоги&lt;/h2&gt;

&lt;p&gt;Если необходимо смоделировать данные, то важно разобраться с целью модели, так как каждое представление закрывает определенные потребности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальная модель – говорит о том, какие данные используются системой и как данные связаны между собой. Подойдет если важно понять что за данные нужны в бизнес логике и как данные связаны между собой;&lt;/li&gt;
  &lt;li&gt;Логическая модель – говорит о том, как данные структурируются в приложении. Поможет описать или посмотреть на схему бд. Можно сгенерировать автоматически;&lt;/li&gt;
  &lt;li&gt;Физическая модель – говорит о том, как данные физически храниться будут. Сам не использовал, но допускаю, что поможет в инфраструктурных документах;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если нужно визуализировать схему бд, то тут два варианта: для мелких схем или для примеров лучше взять генераторы или diagram as a code инструменты, а для больших схем лучше либо взять инструменты для диаграм, либо посмотреть в сторону dbml, который можно использовать и в качестве генератора.&lt;/p&gt;

&lt;h2 id=&quot;что-еще-почитать-по-теме&quot;&gt;Что еще почитать по теме&lt;/h2&gt;

&lt;p&gt;Если тема data model заинтересовала, собрал четыре ссылки, по которым можно погрузиться в тему глубже. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[en] В статье не рассказывал про archimate. Хотя там так же &lt;a href=&quot;https://eaprincipals.com/data-modeling-with-archi/&quot;&gt;можно сделать нужную data model&lt;/a&gt;. Если используете archi - ничего нового не узнаете, скорее всего;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.mongodb.com/basics/data-modeling&quot;&gt;Статья из блога mongoDB, в которой рассказывается data modelling&lt;/a&gt;. В тексте найдете описание подхода, виды представлений, описание процесса, советы и еще больше инструментов и так далее;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.thoughtspot.com/data-trends/data-modeling/conceptual-data-model-examples&quot;&gt;Статья о том, как сделать концептуальную модель&lt;/a&gt;, какие виды есть и в чем ее преимущества;&lt;/li&gt;
  &lt;li&gt;[en] Серия статей о визуализации бд. По &lt;a href=&quot;https://minimalmodeling.substack.com/p/visual-language-and-database-visualization&quot;&gt;ссылке третья часть&lt;/a&gt;, где упоминаются разные приложения для визуализации: MySQL Workbench,  Anchor,  TLDraw и Arrows.app;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Ретроспектива: ecommerce</title>
   <link href="http://pepegramming.site/blogposts/retrospection-ecommerce/"/>
   <updated>2020-06-03T00:00:00+03:00</updated>
   <id>http://pepegramming.site/blogposts/retrospection-ecommerce</id>
   <content type="html">&lt;p&gt;Год назад я ушел из healthcare стартапа, который являлся ecommerce для лекарств в штатах. Сразу после ухода я написал черновик с советами самому себе о том, что стоит делать сразу, а на что обратить внимание.&lt;/p&gt;

&lt;p&gt;Черновик забылся на год, но, найдя записи в блокноте, выложил в паблик как ретроспективу основанную на опыте и боли. Каждый пункт -  субъективный опыт и не претендуют на единственно верное решение. Если у вас есть похожие советы связанные с ecommerce - пишите комментарии, хочется собрать целый список. В будущем, можно будет сделать подобные списки и для других видов проектов.&lt;/p&gt;

&lt;h2 id=&quot;ордер-и-цены&quot;&gt;Ордер и цены&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cart&lt;/code&gt; - частный случай &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;. Вместо двух сущностей можно взять &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;  со статусом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Купоны появятся. Делать купон отдельной сущностью - усложняет логику и добавит условий в чекаут и рефанд логику. Сегодня, если нужно будет делать добавить купоны в систему - сделаю купон отдельным айтемом с отрицательной ценой (скидкой).&lt;/li&gt;
  &lt;li&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; линковался на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;item&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;price&lt;/code&gt; из базы. Также, аналитики постоянно меняли цены на товары. Такая ситуация привела к мутациям ордера и было тяжело сказать, что и сколько стоило для ордера годичной давности. А пользователь получал не предсказуемый UX, так как возникала гипотетическая ситуация, что в момент чекаута цена на товар меняется и пользователь заплатит больше или меньше чем ожидает. Сегодня я бы помести в каждый &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_item&lt;/code&gt;  JSONB поле для цены которое выглядело следующим образом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSONB: { added_at: &apos;&apos;, price: ... }&lt;/code&gt;. В таком случае нет непредвиденных мутаций, появляется версионирование данных. К тому же, это больше информации для аналитиков.&lt;/li&gt;
  &lt;li&gt;Датасайнтисты захотят менять цены, используя сложные паттерны расчета цены и кучу условий. Это приводит к постоянным изменениям цен в базе данных. Поэтому сформировалось правило, все что относится к ценам стоит как можно раньше изолировать в отдельный домен, сервис, rails engine, что угодно. Разделять стоит не только на уровне логики, но и на уровне данных. Вариант с JSONB полем - частный случай такого разделения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;обсервабилити&quot;&gt;Обсервабилити&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Мониторинг и логирование добавляют контроля и скажут что происходит или подскажут где проблема. Покрывать логами и мониторингом каждую строчку  дорого, поэтому top1 кандидаты: все что связанно с деньгами, checkout&amp;amp;refund flow, изменения в данных, интеграции с партнерами, которые приносят деньги. Подход коррелирует с правилом “знайте, что происходит в частях системы, которые приносят деньги”.&lt;/li&gt;
  &lt;li&gt;Работу с деньгами стоит начинать с логов. Если нет ELK или хранилища для логов в котором можно найти информацию без боли - используйте базу данны. Решение для старта - отдельная аудит таблица куда будет попадать информация от платежного шлюза. Такая информация будет полезна как в дебаге, так и аналитикам для создания моделей.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;архитектура&quot;&gt;Архитектура&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Если в системе присутствуют мобильные устройства и другие виды клиентов (например b2b интеграции), значит стоит подумать о версионировании и заложить работу с версиями с самого начала. Кроме версионирования контроллера есть версионирование бизнес логики и версионирование данных.&lt;/li&gt;
  &lt;li&gt;Если клиентов больше двух рекомендую  почитать о &lt;a href=&quot;https://samnewman.io/patterns/architectural/bff/&quot;&gt;BFF паттерне&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Если событий нет в коде - вероятность появления крайне высока. Sidekiq не предназначен для event driven architecture, хотя помогает отодвинуть переход на новую архитектуру и работает для бэкграунд процессинга или в самом начале работы проекта. Поэтому стоит заложить в имплементацию последующее использование событий вне сайдкика.&lt;/li&gt;
  &lt;li&gt;Код без событий для бизнеса и аналитиков - деньги на ветер. Стоит с самого старта проекта заложить, что события относящиеся к работе бизнеса нужно отправлять. Не обязательно использовать сложные решения или платить за SaaS продукты. Например, в собственных проектах шлю события в телеграм, а некоторые пишу в базу.&lt;/li&gt;
  &lt;li&gt;Kafka как брокер событий с самого старта - провал. Это дорого и очень дорого. Если хоститесь в клауде - sqs или google pub/sub могут стать хорошим началом. Если нет - выбирайте из селфхостед аналогов. Также, стоит сразу подумать о прямой и обратной совместимости данных в событиях, а также о schema registry. Как хак подойдет отдельный репозиторий со схемами событий.&lt;/li&gt;
  &lt;li&gt;Временное остаётся навсегда. Так технология добавленная на 2 спринта осталась в проекте на 2 года.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;данные-и-etl&quot;&gt;Данные и ETL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;В маркете возникает ситуация, когда регулярно надо загружать новые данные. Пример - цены на товары и сама информация по товарам. Вместо создания rake тасков для загрузки csv в базу, стоит посмотреть на ETL и заложить работу с ним в архитектуру. Из  аналогов можно посмотреть на &lt;a href=&quot;https://github.com/thbar/kiba&quot;&gt;kiba&lt;/a&gt; (написан на руби) и &lt;a href=&quot;https://airflow.apache.org&quot;&gt;Apache Airflow&lt;/a&gt;, написанный на питоне.&lt;/li&gt;
  &lt;li&gt;Желательно подумать о том, как выгружать данные из приложения аналитикам заранее. Шарить дамп БД может оказаться быстрым вариантом, но в долгосрочной перспективе принесет проблемы совместимости между схемой данных в базе и схемой данных у аналитиков. Как альтернативное решение может подойти событийный подход. Но стоит заранее подумать о схеме данных, версионировании и обратной совместимости между версиями.&lt;/li&gt;
  &lt;li&gt;Аналитики хотят видеть динамику по данным и делают из дампов за разные дни список изменений. Событийный обмен данными также поможет в этой проблеме.&lt;/li&gt;
  &lt;li&gt;Если в домене присутствует специфический ID с определенной структурой - сделайте эту структуру на уровне базы и приводите к этой структуре в бизнес логике. Например, у нас был &lt;a href=&quot;https://en.wikipedia.org/wiki/National_Drug_Code&quot;&gt;National Drug Code&lt;/a&gt;. Это строка которая может содержать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxx-xxxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-x&lt;/code&gt; (10 знаков) или &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-xx&lt;/code&gt; (11 знаков) значения. Спустя год разработки вскрылось, что система содержит три формата этого кода и часть системы поддерживает только десятизначный формат, а на одиннадцатизначном падает с ошибкой. Договорились о стандарте &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5-4-2&lt;/code&gt; (11 знаков), сделали триггер на базу данных, чтобы лефтпадить значение до 11 чисел в строке (недостающие значения забивать нулями) и констрейн в базу данных на не больше 11 символов. В бизнес логике значение через лефтпад приводим к строке 11 символов (с нулями). В таком случае продюсер присылает данные в своем формате, а мы не боимся что в бд будет не валидное значение.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Нашли опечатку или ошибку? Буду рад если &lt;a href=&quot;https://github.com/2pegramming/2pegramming.github.io/tree/master/posts&quot;&gt;пошлете PR в гитхаб&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
